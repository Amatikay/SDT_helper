## S Принцип единственной ответственности.
<b>Для каждого класса должно быть определено единственное назначение.
Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы
в этот класс и подчинены только этой задаче.</b>  
Решение: Разделить большой класс на множество маленьких.
## O Принцип открытости/закрытости
<b>Программные сущности … должны быть открыты для расширения, но закрыты для модификации.</b>  
Решение: Написать интерфейс, и наследовать его с последующими расширениями.
## L Принцип подстановки Лисков
<b>Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.</b>  
Решение: Переопределение методов наследника так, чтобы они соответсвовали пред и пост условиям родителя. Создать интерфейс верхнего уровня.
## I Принцип разделения интерфейса
<b>Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения</b>  
Решение: Создать несколько интерфейсов для отдельных задач. Пусть наследуется несколько нужных интерфейсов.
`class Square : public IDrawable, public IRotatable{}`
## D Принцип инверсии зависимостей
<b>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</b>  
Решение: Создание высокоуровневого интерфейса который будет связан в свысокоуровневыми классамии его будут реализовывать низкоуровненвые классы.
`class Report{ IDatabase* database; ... } class MySQL_DB: public IDatabase {}` 
